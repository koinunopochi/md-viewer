# リファクタリングルール

## 🎯 最上位ルール

このプロジェクトのリファクタリングは、以下のルールに厳密に従って進めること：

1. **TDD（テスト駆動開発）の徹底**
2. **ミノ駆動による責任の分離**
3. **TypeScriptへの段階的移行**
4. **各ステップでのコミット**

## 📋 TDDサイクル

### RED → GREEN → REFACTOR

1. **RED（テストを書く）**
   - まず失敗するテストを書く
   - テストは具体的で、1つの振る舞いのみをテストする
   - テストファースト：実装より先にテストを書く

2. **GREEN（テストを通す）**
   - テストを通すための最小限の実装をする
   - この段階では汚いコードでも構わない
   - とにかくテストを通すことに集中

3. **REFACTOR（リファクタリング）**
   - テストが通った状態を保ちながらコードを改善
   - 重複を除去し、可読性を向上
   - 設計を改善

### コミット戦略

```
feat: 🔴 [機能名]のテストを追加
feat: 🟢 [機能名]の最小実装でテストをパス
refactor: ♻️ [機能名]のリファクタリング
```

## 🏗️ ミノ駆動の責任分離

### 単一責任の原則（SRP）

各クラス・モジュールは1つの責任のみを持つ：

1. **FileService** - ファイルシステム操作
2. **MarkdownRenderer** - Markdown→HTML変換
3. **MermaidRenderer** - Mermaidダイアグラム処理
4. **MarpRenderer** - Marpプレゼンテーション処理
5. **ServerController** - HTTPリクエスト処理
6. **DirectoryTreeBuilder** - ディレクトリ構造の構築
7. **PathResolver** - パス解決とセキュリティ

### 依存性逆転の原則（DIP）

- インターフェースに依存し、具象クラスに依存しない
- DIコンテナまたはFactory patternを使用

## 📝 TypeScript移行戦略

### 段階的移行

1. **Phase 1: 型定義の追加**
   - JSDocコメントで型情報を追加
   - TypeScript設定ファイルの作成
   - 型定義ファイル（.d.ts）の作成

2. **Phase 2: ファイル単位での移行**
   - 末端のモジュールから.tsへ変換
   - strictモードは段階的に有効化

3. **Phase 3: 完全移行**
   - すべてのファイルをTypeScriptに
   - strictモードを完全に有効化

## 🧪 テスト方針

### テストの種類

1. **ユニットテスト**
   - Jest + ts-jestを使用
   - 各クラス・関数の単体テスト
   - モックを活用した独立性の確保

2. **統合テスト**
   - Supertestを使用
   - APIエンドポイントのテスト
   - 実際のファイルシステムを使用

### テストの書き方

```typescript
describe('MarkdownRenderer', () => {
  describe('render', () => {
    it('should convert markdown to HTML', () => {
      // Given
      const markdown = '# Hello World';
      const renderer = new MarkdownRenderer();
      
      // When
      const html = renderer.render(markdown);
      
      // Then
      expect(html).toContain('<h1>Hello World</h1>');
    });
  });
});
```

## 🔄 リファクタリング手順

### 1. 現状の理解
- 既存コードの責任を明確化
- 依存関係を図示
- リファクタリング対象を特定

### 2. テストの作成
- 現在の振る舞いをテストで保護
- エッジケースも含める
- カバレッジ80%以上を目指す

### 3. 段階的な改善
- 小さな変更を積み重ねる
- 各変更後にテストを実行
- グリーンを保ちながら進める

### 4. 責任の分離
- 大きなクラスを分割
- 共通処理を抽出
- インターフェースを定義

## 📊 品質指標

### コード品質
- 関数の行数: 20行以下
- クラスの行数: 200行以下
- 循環的複雑度: 10以下
- テストカバレッジ: 80%以上

### 命名規則
- クラス: PascalCase
- インターフェース: IPascalCase
- 関数・変数: camelCase
- 定数: UPPER_SNAKE_CASE

## 🚀 実行順序

1. **準備**
   - TypeScript, Jest, ESLintの設定
   - 初期テストの作成

2. **コア機能の分離**
   - ファイル読み込み機能
   - Markdown変換機能
   - ルーティング機能

3. **拡張機能の分離**
   - Mermaid処理
   - Marp処理
   - チャット形式変換

4. **統合**
   - DIコンテナの導入
   - エラーハンドリングの統一
   - ログ機能の追加

## ⚠️ 注意事項

- **ビッグバンリファクタリングは避ける**
- **常に動作する状態を保つ**
- **テストなしでのリファクタリングは禁止**
- **1つのPRで1つの責任を改善**

---

このルールに従い、安全で段階的なリファクタリングを実現する。